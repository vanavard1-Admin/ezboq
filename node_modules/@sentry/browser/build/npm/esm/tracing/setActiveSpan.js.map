{"version":3,"file":"setActiveSpan.js","sources":["../../../../src/tracing/setActiveSpan.ts"],"sourcesContent":["import type { Span } from '@sentry/core';\nimport { _INTERNAL_setSpanForScope, getActiveSpan, getCurrentScope } from '@sentry/core';\n\n/**\n * Sets an inactive span active on the current scope.\n *\n * This is useful in browser applications, if you want to create a span that cannot be finished\n * within its callback. Any spans started while the given span is active, will be children of the span.\n *\n * If there already was an active span on the scope prior to calling this function, it is replaced\n * with the given span and restored after the span ended. Otherwise, the span will simply be\n * removed, resulting in no active span on the scope.\n *\n * IMPORTANT: This function can ONLY be used in the browser! Calling this function in a server\n * environment (for example in a server-side rendered component) will result in undefined behaviour\n * and is not supported.\n * You MUST call `span.end()` manually, otherwise the span will never be finished.\n *\n * @example\n * ```js\n * let checkoutSpan;\n *\n * on('checkoutStarted', () => {\n *  checkoutSpan = Sentry.startInactiveSpan({ name: 'checkout-flow' });\n *  Sentry.setActiveSpanInBrowser(checkoutSpan);\n * })\n *\n * // during this time, any spans started will be children of `checkoutSpan`:\n * Sentry.startSpan({ name: 'checkout-step-1' }, () => {\n *  // ... `\n * })\n *\n * on('checkoutCompleted', () => {\n *  checkoutSpan?.end();\n * })\n * ```\n *\n * @param span - the span to set active\n */\nexport function setActiveSpanInBrowser(span: Span): void {\n  const maybePreviousActiveSpan = getActiveSpan();\n\n  // If the span is already active, there's no need to double-patch or set it again.\n  // This also guards against users (for whatever reason) calling setActiveSpanInBrowser on SDK-started\n  // idle spans like pageload or navigation spans. These will already be handled correctly by the SDK.\n  // For nested situations, we have to double-patch to ensure we restore the correct previous span (see tests)\n  if (maybePreviousActiveSpan === span) {\n    return;\n  }\n\n  const scope = getCurrentScope();\n\n  // Putting a small patch onto the span.end method to ensure we\n  // remove the span from the scope when it ends.\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  span.end = new Proxy(span.end, {\n    apply(target, thisArg, args: Parameters<Span['end']>) {\n      _INTERNAL_setSpanForScope(scope, maybePreviousActiveSpan);\n      return Reflect.apply(target, thisArg, args);\n    },\n  });\n\n  _INTERNAL_setSpanForScope(scope, span);\n}\n"],"names":[],"mappings":";;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,sBAAsB,CAAC,IAAI,EAAc;AACzD,EAAE,MAAM,uBAAA,GAA0B,aAAa,EAAE;;AAEjD;AACA;AACA;AACA;AACA,EAAE,IAAI,uBAAA,KAA4B,IAAI,EAAE;AACxC,IAAI;AACJ;;AAEA,EAAE,MAAM,KAAA,GAAQ,eAAe,EAAE;;AAEjC;AACA;AACA;AACA,EAAE,IAAI,CAAC,GAAA,GAAM,IAAI,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE;AACjC,IAAI,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,EAA2B;AAC1D,MAAM,yBAAyB,CAAC,KAAK,EAAE,uBAAuB,CAAC;AAC/D,MAAM,OAAO,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC;AACjD,KAAK;AACL,GAAG,CAAC;;AAEJ,EAAE,yBAAyB,CAAC,KAAK,EAAE,IAAI,CAAC;AACxC;;;;"}