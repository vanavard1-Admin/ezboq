{"version":3,"file":"traceLifecycleProfiler.js","sources":["../../../../../src/profiling/lifecycleMode/traceLifecycleProfiler.ts"],"sourcesContent":["import type { Client, ProfileChunk, Span } from '@sentry/core';\nimport {\n  type ProfileChunkEnvelope,\n  createEnvelope,\n  debug,\n  dsnToString,\n  getGlobalScope,\n  getRootSpan,\n  getSdkMetadataForEnvelopeHeader,\n  uuid4,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport type { JSSelfProfiler } from '../jsSelfProfiling';\nimport { createProfileChunkPayload, startJSSelfProfile, validateProfileChunk } from '../utils';\n\nconst CHUNK_INTERVAL_MS = 60_000; // 1 minute\n// Maximum length for trace lifecycle profiling per root span (e.g. if spanEnd never fires)\nconst MAX_ROOT_SPAN_PROFILE_MS = 300_000; // 5 minutes\n\n/**\n * Browser trace-lifecycle profiler (UI Profiling / Profiling V2):\n * - Starts when the first sampled root span starts\n * - Stops when the last sampled root span ends\n * - While running, periodically stops and restarts the JS self-profiling API to collect chunks\n *\n * Profiles are emitted as standalone `profile_chunk` envelopes either when:\n * - there are no more sampled root spans, or\n * - the 60s chunk timer elapses while profiling is running.\n */\nexport class BrowserTraceLifecycleProfiler {\n  private _client: Client | undefined;\n  private _profiler: JSSelfProfiler | undefined;\n  private _chunkTimer: ReturnType<typeof setTimeout> | undefined;\n  // For keeping track of active root spans\n  private _activeRootSpanIds: Set<string>;\n  private _rootSpanTimeouts: Map<string, ReturnType<typeof setTimeout>>;\n  // ID for Profiler session\n  private _profilerId: string | undefined;\n  private _isRunning: boolean;\n  private _sessionSampled: boolean;\n\n  public constructor() {\n    this._client = undefined;\n    this._profiler = undefined;\n    this._chunkTimer = undefined;\n    this._activeRootSpanIds = new Set<string>();\n    this._rootSpanTimeouts = new Map<string, ReturnType<typeof setTimeout>>();\n    this._profilerId = undefined;\n    this._isRunning = false;\n    this._sessionSampled = false;\n  }\n\n  /**\n   * Initialize the profiler with client and session sampling decision computed by the integration.\n   */\n  public initialize(client: Client, sessionSampled: boolean): void {\n    // One Profiler ID per profiling session (user session)\n    this._profilerId = uuid4();\n\n    DEBUG_BUILD && debug.log(\"[Profiling] Initializing profiler (lifecycle='trace').\");\n\n    this._client = client;\n    this._sessionSampled = sessionSampled;\n\n    client.on('spanStart', span => {\n      if (!this._sessionSampled) {\n        DEBUG_BUILD && debug.log('[Profiling] Session not sampled because of negative sampling decision.');\n        return;\n      }\n      if (span !== getRootSpan(span)) {\n        return;\n      }\n      // Only count sampled root spans\n      if (!span.isRecording()) {\n        DEBUG_BUILD && debug.log('[Profiling] Discarding profile because root span was not sampled.');\n        return;\n      }\n\n      // Matching root spans with profiles\n      getGlobalScope().setContext('profile', {\n        profiler_id: this._profilerId,\n      });\n\n      const spanId = span.spanContext().spanId;\n      if (!spanId) {\n        return;\n      }\n      if (this._activeRootSpanIds.has(spanId)) {\n        return;\n      }\n\n      this._activeRootSpanIds.add(spanId);\n      const rootSpanCount = this._activeRootSpanIds.size;\n\n      const timeout = setTimeout(() => {\n        this._onRootSpanTimeout(spanId);\n      }, MAX_ROOT_SPAN_PROFILE_MS);\n      this._rootSpanTimeouts.set(spanId, timeout);\n\n      if (rootSpanCount === 1) {\n        DEBUG_BUILD &&\n          debug.log(\n            `[Profiling] Root span with ID ${spanId} started. Will continue profiling for as long as there are active root spans (currently: ${rootSpanCount}).`,\n          );\n\n        this.start();\n      }\n    });\n\n    client.on('spanEnd', span => {\n      if (!this._sessionSampled) {\n        return;\n      }\n\n      const spanId = span.spanContext().spanId;\n      if (!spanId || !this._activeRootSpanIds.has(spanId)) {\n        return;\n      }\n\n      this._activeRootSpanIds.delete(spanId);\n      const rootSpanCount = this._activeRootSpanIds.size;\n\n      DEBUG_BUILD &&\n        debug.log(\n          `[Profiling] Root span with ID ${spanId} ended. Will continue profiling for as long as there are active root spans (currently: ${rootSpanCount}).`,\n        );\n      if (rootSpanCount === 0) {\n        this._collectCurrentChunk().catch(e => {\n          DEBUG_BUILD && debug.error('[Profiling] Failed to collect current profile chunk on `spanEnd`:', e);\n        });\n\n        this.stop();\n      }\n    });\n  }\n\n  /**\n   * Handle an already-active root span at integration setup time.\n   */\n  public notifyRootSpanActive(rootSpan: Span): void {\n    if (!this._sessionSampled) {\n      return;\n    }\n\n    const spanId = rootSpan.spanContext().spanId;\n    if (!spanId || this._activeRootSpanIds.has(spanId)) {\n      return;\n    }\n\n    this._activeRootSpanIds.add(spanId);\n\n    const rootSpanCount = this._activeRootSpanIds.size;\n\n    if (rootSpanCount === 1) {\n      DEBUG_BUILD &&\n        debug.log('[Profiling] Detected already active root span during setup. Active root spans now:', rootSpanCount);\n\n      this.start();\n    }\n  }\n\n  /**\n   * Start profiling if not already running.\n   */\n  public start(): void {\n    if (this._isRunning) {\n      return;\n    }\n    this._isRunning = true;\n\n    DEBUG_BUILD && debug.log('[Profiling] Started profiling with profile ID:', this._profilerId);\n\n    this._startProfilerInstance();\n\n    if (!this._profiler) {\n      DEBUG_BUILD && debug.log('[Profiling] Stopping trace lifecycle profiling.');\n      this._resetProfilerInfo();\n      return;\n    }\n\n    this._startPeriodicChunking();\n  }\n\n  /**\n   * Stop profiling; final chunk will be collected and sent.\n   */\n  public stop(): void {\n    if (!this._isRunning) {\n      return;\n    }\n\n    this._isRunning = false;\n    if (this._chunkTimer) {\n      clearTimeout(this._chunkTimer);\n      this._chunkTimer = undefined;\n    }\n\n    this._clearAllRootSpanTimeouts();\n\n    // Collect whatever was currently recording\n    this._collectCurrentChunk().catch(e => {\n      DEBUG_BUILD && debug.error('[Profiling] Failed to collect current profile chunk on `stop()`:', e);\n    });\n  }\n\n  /**\n   * Resets profiling information from scope and resets running state\n   */\n  private _resetProfilerInfo(): void {\n    this._isRunning = false;\n    getGlobalScope().setContext('profile', {});\n  }\n\n  /**\n   * Clear and reset all per-root-span timeouts.\n   */\n  private _clearAllRootSpanTimeouts(): void {\n    this._rootSpanTimeouts.forEach(timeout => clearTimeout(timeout));\n    this._rootSpanTimeouts.clear();\n  }\n\n  /**\n   * Start a profiler instance if needed.\n   */\n  private _startProfilerInstance(): void {\n    if (this._profiler?.stopped === false) {\n      return;\n    }\n    const profiler = startJSSelfProfile();\n    if (!profiler) {\n      DEBUG_BUILD && debug.log('[Profiling] Failed to start JS Profiler in trace lifecycle.');\n      return;\n    }\n    this._profiler = profiler;\n  }\n\n  /**\n   * Schedule the next 60s chunk while running.\n   * Each tick collects a chunk and restarts the profiler.\n   * A chunk should be closed when there are no active root spans anymore OR when the maximum chunk interval is reached.\n   */\n  private _startPeriodicChunking(): void {\n    if (!this._isRunning) {\n      return;\n    }\n\n    this._chunkTimer = setTimeout(() => {\n      this._collectCurrentChunk().catch(e => {\n        DEBUG_BUILD && debug.error('[Profiling] Failed to collect current profile chunk during periodic chunking:', e);\n      });\n\n      if (this._isRunning) {\n        this._startProfilerInstance();\n\n        if (!this._profiler) {\n          // If restart failed, stop scheduling further chunks and reset context.\n          this._resetProfilerInfo();\n          return;\n        }\n\n        this._startPeriodicChunking();\n      }\n    }, CHUNK_INTERVAL_MS);\n  }\n\n  /**\n   * Handle timeout for a specific root span ID to avoid indefinitely running profiler if `spanEnd` never fires.\n   * If this was the last active root span, collect the current chunk and stop profiling.\n   */\n  private _onRootSpanTimeout(rootSpanId: string): void {\n    // If span already ended, ignore\n    if (!this._rootSpanTimeouts.has(rootSpanId)) {\n      return;\n    }\n    this._rootSpanTimeouts.delete(rootSpanId);\n\n    if (!this._activeRootSpanIds.has(rootSpanId)) {\n      return;\n    }\n\n    DEBUG_BUILD &&\n      debug.log(\n        `[Profiling] Reached 5-minute timeout for root span ${rootSpanId}. You likely started a manual root span that never called \\`.end()\\`.`,\n      );\n\n    this._activeRootSpanIds.delete(rootSpanId);\n\n    const rootSpanCount = this._activeRootSpanIds.size;\n    if (rootSpanCount === 0) {\n      this.stop();\n    }\n  }\n\n  /**\n   * Stop the current profiler, convert and send a profile chunk.\n   */\n  private async _collectCurrentChunk(): Promise<void> {\n    const prevProfiler = this._profiler;\n    this._profiler = undefined;\n\n    if (!prevProfiler) {\n      return;\n    }\n\n    try {\n      const profile = await prevProfiler.stop();\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const chunk = createProfileChunkPayload(profile, this._client!, this._profilerId);\n\n      // Validate chunk before sending\n      const validationReturn = validateProfileChunk(chunk);\n      if ('reason' in validationReturn) {\n        DEBUG_BUILD &&\n          debug.log(\n            '[Profiling] Discarding invalid profile chunk (this is probably a bug in the SDK):',\n            validationReturn.reason,\n          );\n        return;\n      }\n\n      this._sendProfileChunk(chunk);\n\n      DEBUG_BUILD && debug.log('[Profiling] Collected browser profile chunk.');\n    } catch (e) {\n      DEBUG_BUILD && debug.log('[Profiling] Error while stopping JS Profiler for chunk:', e);\n    }\n  }\n\n  /**\n   * Send a profile chunk as a standalone envelope.\n   */\n  private _sendProfileChunk(chunk: ProfileChunk): void {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const client = this._client!;\n\n    const sdkInfo = getSdkMetadataForEnvelopeHeader(client.getSdkMetadata?.());\n    const dsn = client.getDsn();\n    const tunnel = client.getOptions().tunnel;\n\n    const envelope = createEnvelope<ProfileChunkEnvelope>(\n      {\n        event_id: uuid4(),\n        sent_at: new Date().toISOString(),\n        ...(sdkInfo && { sdk: sdkInfo }),\n        ...(!!tunnel && dsn && { dsn: dsnToString(dsn) }),\n      },\n      [[{ type: 'profile_chunk' }, chunk]],\n    );\n\n    client.sendEnvelope(envelope).then(null, reason => {\n      DEBUG_BUILD && debug.error('Error while sending profile chunk envelope:', reason);\n    });\n  }\n}\n"],"names":[],"mappings":";;;;AAeA,MAAM,iBAAA,GAAoB,KAAM,CAAA;AAChC;AACA,MAAM,wBAAA,GAA2B,MAAO,CAAA;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,6BAAA,CAA8B;;AAI3C;;AAGA;;AAKA,GAAS,WAAW,GAAG;AACvB,IAAI,IAAI,CAAC,OAAA,GAAU,SAAS;AAC5B,IAAI,IAAI,CAAC,SAAA,GAAY,SAAS;AAC9B,IAAI,IAAI,CAAC,WAAA,GAAc,SAAS;AAChC,IAAI,IAAI,CAAC,kBAAA,GAAqB,IAAI,GAAG,EAAU;AAC/C,IAAI,IAAI,CAAC,iBAAA,GAAoB,IAAI,GAAG,EAAyC;AAC7E,IAAI,IAAI,CAAC,WAAA,GAAc,SAAS;AAChC,IAAI,IAAI,CAAC,UAAA,GAAa,KAAK;AAC3B,IAAI,IAAI,CAAC,eAAA,GAAkB,KAAK;AAChC;;AAEA;AACA;AACA;AACA,GAAS,UAAU,CAAC,MAAM,EAAU,cAAc,EAAiB;AACnE;AACA,IAAI,IAAI,CAAC,WAAA,GAAc,KAAK,EAAE;;AAE9B,IAAI,eAAe,KAAK,CAAC,GAAG,CAAC,wDAAwD,CAAC;;AAEtF,IAAI,IAAI,CAAC,OAAA,GAAU,MAAM;AACzB,IAAI,IAAI,CAAC,eAAA,GAAkB,cAAc;;AAEzC,IAAI,MAAM,CAAC,EAAE,CAAC,WAAW,EAAE,QAAQ;AACnC,MAAM,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;AACjC,QAAQ,eAAe,KAAK,CAAC,GAAG,CAAC,wEAAwE,CAAC;AAC1G,QAAQ;AACR;AACA,MAAM,IAAI,IAAA,KAAS,WAAW,CAAC,IAAI,CAAC,EAAE;AACtC,QAAQ;AACR;AACA;AACA,MAAM,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE;AAC/B,QAAQ,eAAe,KAAK,CAAC,GAAG,CAAC,mEAAmE,CAAC;AACrG,QAAQ;AACR;;AAEA;AACA,MAAM,cAAc,EAAE,CAAC,UAAU,CAAC,SAAS,EAAE;AAC7C,QAAQ,WAAW,EAAE,IAAI,CAAC,WAAW;AACrC,OAAO,CAAC;;AAER,MAAM,MAAM,SAAS,IAAI,CAAC,WAAW,EAAE,CAAC,MAAM;AAC9C,MAAM,IAAI,CAAC,MAAM,EAAE;AACnB,QAAQ;AACR;AACA,MAAM,IAAI,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;AAC/C,QAAQ;AACR;;AAEA,MAAM,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,MAAM,CAAC;AACzC,MAAM,MAAM,aAAA,GAAgB,IAAI,CAAC,kBAAkB,CAAC,IAAI;;AAExD,MAAM,MAAM,OAAA,GAAU,UAAU,CAAC,MAAM;AACvC,QAAQ,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC;AACvC,OAAO,EAAE,wBAAwB,CAAC;AAClC,MAAM,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC;;AAEjD,MAAM,IAAI,aAAA,KAAkB,CAAC,EAAE;AAC/B,QAAQ,WAAA;AACR,UAAU,KAAK,CAAC,GAAG;AACnB,YAAY,CAAC,8BAA8B,EAAE,MAAM,CAAC,yFAAyF,EAAE,aAAa,CAAC,EAAE,CAAC;AAChK,WAAW;;AAEX,QAAQ,IAAI,CAAC,KAAK,EAAE;AACpB;AACA,KAAK,CAAC;;AAEN,IAAI,MAAM,CAAC,EAAE,CAAC,SAAS,EAAE,QAAQ;AACjC,MAAM,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;AACjC,QAAQ;AACR;;AAEA,MAAM,MAAM,SAAS,IAAI,CAAC,WAAW,EAAE,CAAC,MAAM;AAC9C,MAAM,IAAI,CAAC,MAAA,IAAU,CAAC,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;AAC3D,QAAQ;AACR;;AAEA,MAAM,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,MAAM,CAAC;AAC5C,MAAM,MAAM,aAAA,GAAgB,IAAI,CAAC,kBAAkB,CAAC,IAAI;;AAExD,MAAM,WAAA;AACN,QAAQ,KAAK,CAAC,GAAG;AACjB,UAAU,CAAC,8BAA8B,EAAE,MAAM,CAAC,uFAAuF,EAAE,aAAa,CAAC,EAAE,CAAC;AAC5J,SAAS;AACT,MAAM,IAAI,aAAA,KAAkB,CAAC,EAAE;AAC/B,QAAQ,IAAI,CAAC,oBAAoB,EAAE,CAAC,KAAK,CAAC,CAAA,IAAK;AAC/C,UAAU,WAAA,IAAe,KAAK,CAAC,KAAK,CAAC,mEAAmE,EAAE,CAAC,CAAC;AAC5G,SAAS,CAAC;;AAEV,QAAQ,IAAI,CAAC,IAAI,EAAE;AACnB;AACA,KAAK,CAAC;AACN;;AAEA;AACA;AACA;AACA,GAAS,oBAAoB,CAAC,QAAQ,EAAc;AACpD,IAAI,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;AAC/B,MAAM;AACN;;AAEA,IAAI,MAAM,SAAS,QAAQ,CAAC,WAAW,EAAE,CAAC,MAAM;AAChD,IAAI,IAAI,CAAC,MAAA,IAAU,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;AACxD,MAAM;AACN;;AAEA,IAAI,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,MAAM,CAAC;;AAEvC,IAAI,MAAM,aAAA,GAAgB,IAAI,CAAC,kBAAkB,CAAC,IAAI;;AAEtD,IAAI,IAAI,aAAA,KAAkB,CAAC,EAAE;AAC7B,MAAM,WAAA;AACN,QAAQ,KAAK,CAAC,GAAG,CAAC,oFAAoF,EAAE,aAAa,CAAC;;AAEtH,MAAM,IAAI,CAAC,KAAK,EAAE;AAClB;AACA;;AAEA;AACA;AACA;AACA,GAAS,KAAK,GAAS;AACvB,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE;AACzB,MAAM;AACN;AACA,IAAI,IAAI,CAAC,UAAA,GAAa,IAAI;;AAE1B,IAAI,WAAA,IAAe,KAAK,CAAC,GAAG,CAAC,gDAAgD,EAAE,IAAI,CAAC,WAAW,CAAC;;AAEhG,IAAI,IAAI,CAAC,sBAAsB,EAAE;;AAEjC,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;AACzB,MAAM,eAAe,KAAK,CAAC,GAAG,CAAC,iDAAiD,CAAC;AACjF,MAAM,IAAI,CAAC,kBAAkB,EAAE;AAC/B,MAAM;AACN;;AAEA,IAAI,IAAI,CAAC,sBAAsB,EAAE;AACjC;;AAEA;AACA;AACA;AACA,GAAS,IAAI,GAAS;AACtB,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;AAC1B,MAAM;AACN;;AAEA,IAAI,IAAI,CAAC,UAAA,GAAa,KAAK;AAC3B,IAAI,IAAI,IAAI,CAAC,WAAW,EAAE;AAC1B,MAAM,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC;AACpC,MAAM,IAAI,CAAC,WAAA,GAAc,SAAS;AAClC;;AAEA,IAAI,IAAI,CAAC,yBAAyB,EAAE;;AAEpC;AACA,IAAI,IAAI,CAAC,oBAAoB,EAAE,CAAC,KAAK,CAAC,CAAA,IAAK;AAC3C,MAAM,WAAA,IAAe,KAAK,CAAC,KAAK,CAAC,kEAAkE,EAAE,CAAC,CAAC;AACvG,KAAK,CAAC;AACN;;AAEA;AACA;AACA;AACA,GAAU,kBAAkB,GAAS;AACrC,IAAI,IAAI,CAAC,UAAA,GAAa,KAAK;AAC3B,IAAI,cAAc,EAAE,CAAC,UAAU,CAAC,SAAS,EAAE,EAAE,CAAC;AAC9C;;AAEA;AACA;AACA;AACA,GAAU,yBAAyB,GAAS;AAC5C,IAAI,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,OAAA,IAAW,YAAY,CAAC,OAAO,CAAC,CAAC;AACpE,IAAI,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE;AAClC;;AAEA;AACA;AACA;AACA,GAAU,sBAAsB,GAAS;AACzC,IAAI,IAAI,IAAI,CAAC,SAAS,EAAE,OAAA,KAAY,KAAK,EAAE;AAC3C,MAAM;AACN;AACA,IAAI,MAAM,QAAA,GAAW,kBAAkB,EAAE;AACzC,IAAI,IAAI,CAAC,QAAQ,EAAE;AACnB,MAAM,eAAe,KAAK,CAAC,GAAG,CAAC,6DAA6D,CAAC;AAC7F,MAAM;AACN;AACA,IAAI,IAAI,CAAC,SAAA,GAAY,QAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAU,sBAAsB,GAAS;AACzC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;AAC1B,MAAM;AACN;;AAEA,IAAI,IAAI,CAAC,WAAA,GAAc,UAAU,CAAC,MAAM;AACxC,MAAM,IAAI,CAAC,oBAAoB,EAAE,CAAC,KAAK,CAAC,CAAA,IAAK;AAC7C,QAAQ,WAAA,IAAe,KAAK,CAAC,KAAK,CAAC,+EAA+E,EAAE,CAAC,CAAC;AACtH,OAAO,CAAC;;AAER,MAAM,IAAI,IAAI,CAAC,UAAU,EAAE;AAC3B,QAAQ,IAAI,CAAC,sBAAsB,EAAE;;AAErC,QAAQ,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;AAC7B;AACA,UAAU,IAAI,CAAC,kBAAkB,EAAE;AACnC,UAAU;AACV;;AAEA,QAAQ,IAAI,CAAC,sBAAsB,EAAE;AACrC;AACA,KAAK,EAAE,iBAAiB,CAAC;AACzB;;AAEA;AACA;AACA;AACA;AACA,GAAU,kBAAkB,CAAC,UAAU,EAAgB;AACvD;AACA,IAAI,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;AACjD,MAAM;AACN;AACA,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,UAAU,CAAC;;AAE7C,IAAI,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;AAClD,MAAM;AACN;;AAEA,IAAI,WAAA;AACJ,MAAM,KAAK,CAAC,GAAG;AACf,QAAQ,CAAC,mDAAmD,EAAE,UAAU,CAAC,qEAAqE,CAAC;AAC/I,OAAO;;AAEP,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,UAAU,CAAC;;AAE9C,IAAI,MAAM,aAAA,GAAgB,IAAI,CAAC,kBAAkB,CAAC,IAAI;AACtD,IAAI,IAAI,aAAA,KAAkB,CAAC,EAAE;AAC7B,MAAM,IAAI,CAAC,IAAI,EAAE;AACjB;AACA;;AAEA;AACA;AACA;AACA,GAAU,MAAM,oBAAoB,GAAkB;AACtD,IAAI,MAAM,YAAA,GAAe,IAAI,CAAC,SAAS;AACvC,IAAI,IAAI,CAAC,SAAA,GAAY,SAAS;;AAE9B,IAAI,IAAI,CAAC,YAAY,EAAE;AACvB,MAAM;AACN;;AAEA,IAAI,IAAI;AACR,MAAM,MAAM,UAAU,MAAM,YAAY,CAAC,IAAI,EAAE;;AAE/C;AACA,MAAM,MAAM,KAAA,GAAQ,yBAAyB,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,EAAG,IAAI,CAAC,WAAW,CAAC;;AAEvF;AACA,MAAM,MAAM,gBAAA,GAAmB,oBAAoB,CAAC,KAAK,CAAC;AAC1D,MAAM,IAAI,QAAA,IAAY,gBAAgB,EAAE;AACxC,QAAQ,WAAA;AACR,UAAU,KAAK,CAAC,GAAG;AACnB,YAAY,mFAAmF;AAC/F,YAAY,gBAAgB,CAAC,MAAM;AACnC,WAAW;AACX,QAAQ;AACR;;AAEA,MAAM,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;;AAEnC,MAAM,eAAe,KAAK,CAAC,GAAG,CAAC,8CAA8C,CAAC;AAC9E,KAAI,CAAE,OAAO,CAAC,EAAE;AAChB,MAAM,WAAA,IAAe,KAAK,CAAC,GAAG,CAAC,yDAAyD,EAAE,CAAC,CAAC;AAC5F;AACA;;AAEA;AACA;AACA;AACA,GAAU,iBAAiB,CAAC,KAAK,EAAsB;AACvD;AACA,IAAI,MAAM,MAAA,GAAS,IAAI,CAAC,OAAO;;AAE/B,IAAI,MAAM,OAAA,GAAU,+BAA+B,CAAC,MAAM,CAAC,cAAc,IAAI,CAAC;AAC9E,IAAI,MAAM,GAAA,GAAM,MAAM,CAAC,MAAM,EAAE;AAC/B,IAAI,MAAM,SAAS,MAAM,CAAC,UAAU,EAAE,CAAC,MAAM;;AAE7C,IAAI,MAAM,QAAA,GAAW,cAAc;AACnC,MAAM;AACN,QAAQ,QAAQ,EAAE,KAAK,EAAE;AACzB,QAAQ,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;AACzC,QAAQ,IAAI,OAAA,IAAW,EAAE,GAAG,EAAE,OAAA,EAAS,CAAC;AACxC,QAAQ,IAAI,CAAC,CAAC,MAAA,IAAU,GAAA,IAAO,EAAE,GAAG,EAAE,WAAW,CAAC,GAAG,CAAA,EAAG,CAAC;AACzD,OAAO;AACP,MAAM,CAAC,CAAC,EAAE,IAAI,EAAE,iBAAiB,EAAE,KAAK,CAAC,CAAC;AAC1C,KAAK;;AAEL,IAAI,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,MAAA,IAAU;AACvD,MAAM,WAAA,IAAe,KAAK,CAAC,KAAK,CAAC,6CAA6C,EAAE,MAAM,CAAC;AACvF,KAAK,CAAC;AACN;AACA;;;;"}