{"version":3,"file":"instrumentation.js","sources":["../../../src/reactrouter-compat-utils/instrumentation.tsx"],"sourcesContent":["/* eslint-disable max-lines */\n// Inspired from Donnie McNeal's solution:\n// https://gist.github.com/wontondon/e8c4bdf2888875e4c755712e99279536\n\nimport {\n  browserTracingIntegration,\n  startBrowserTracingNavigationSpan,\n  startBrowserTracingPageLoadSpan,\n  WINDOW,\n} from '@sentry/browser';\nimport type { Client, Integration, Span } from '@sentry/core';\nimport {\n  addNonEnumerableProperty,\n  debug,\n  getActiveSpan,\n  getClient,\n  getCurrentScope,\n  getRootSpan,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  spanToJSON,\n} from '@sentry/core';\nimport * as React from 'react';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { hoistNonReactStatics } from '../hoist-non-react-statics';\nimport type {\n  Action,\n  AgnosticDataRouteMatch,\n  CreateRouterFunction,\n  CreateRoutesFromChildren,\n  Location,\n  MatchRoutes,\n  RouteMatch,\n  RouteObject,\n  Router,\n  RouterState,\n  UseEffect,\n  UseLocation,\n  UseNavigationType,\n  UseRoutes,\n} from '../types';\nimport { checkRouteForAsyncHandler } from './lazy-routes';\nimport { initializeRouterUtils, resolveRouteNameAndSource } from './utils';\n\nlet _useEffect: UseEffect;\nlet _useLocation: UseLocation;\nlet _useNavigationType: UseNavigationType;\nlet _createRoutesFromChildren: CreateRoutesFromChildren;\nlet _matchRoutes: MatchRoutes;\nlet _enableAsyncRouteHandlers: boolean = false;\n\nconst CLIENTS_WITH_INSTRUMENT_NAVIGATION = new WeakSet<Client>();\n\n/**\n * Adds resolved routes as children to the parent route.\n * Prevents duplicate routes by checking if they already exist.\n */\nexport function addResolvedRoutesToParent(resolvedRoutes: RouteObject[], parentRoute: RouteObject): void {\n  const existingChildren = parentRoute.children || [];\n\n  const newRoutes = resolvedRoutes.filter(\n    newRoute =>\n      !existingChildren.some(\n        existing =>\n          existing === newRoute ||\n          (newRoute.path && existing.path === newRoute.path) ||\n          (newRoute.id && existing.id === newRoute.id),\n      ),\n  );\n\n  if (newRoutes.length > 0) {\n    parentRoute.children = [...existingChildren, ...newRoutes];\n  }\n}\n\nexport interface ReactRouterOptions {\n  useEffect: UseEffect;\n  useLocation: UseLocation;\n  useNavigationType: UseNavigationType;\n  createRoutesFromChildren: CreateRoutesFromChildren;\n  matchRoutes: MatchRoutes;\n  /**\n   * Whether to strip the basename from the pathname when creating transactions.\n   *\n   * This is useful for applications that use a basename in their routing setup.\n   * @default false\n   */\n  stripBasename?: boolean;\n  /**\n   * Enables support for async route handlers.\n   *\n   * This allows Sentry to track and instrument routes dynamically resolved from async handlers.\n   * @default false\n   */\n  enableAsyncRouteHandlers?: boolean;\n}\n\ntype V6CompatibleVersion = '6' | '7';\n\n// Keeping as a global variable for cross-usage in multiple functions\n// only exported for testing purposes\nexport const allRoutes = new Set<RouteObject>();\n\n/**\n * Processes resolved routes by adding them to allRoutes and checking for nested async handlers.\n */\nexport function processResolvedRoutes(\n  resolvedRoutes: RouteObject[],\n  parentRoute?: RouteObject,\n  currentLocation: Location | null = null,\n): void {\n  resolvedRoutes.forEach(child => {\n    allRoutes.add(child);\n    // Only check for async handlers if the feature is enabled\n    if (_enableAsyncRouteHandlers) {\n      checkRouteForAsyncHandler(child, processResolvedRoutes);\n    }\n  });\n\n  if (parentRoute) {\n    // If a parent route is provided, add the resolved routes as children to the parent route\n    addResolvedRoutesToParent(resolvedRoutes, parentRoute);\n  }\n\n  // After processing lazy routes, check if we need to update an active transaction\n  const activeRootSpan = getActiveRootSpan();\n  if (activeRootSpan) {\n    const spanOp = spanToJSON(activeRootSpan).op;\n\n    // Try to use the provided location first, then fall back to global window location if needed\n    let location = currentLocation;\n    if (!location) {\n      if (typeof WINDOW !== 'undefined') {\n        const globalLocation = WINDOW.location;\n        if (globalLocation) {\n          location = { pathname: globalLocation.pathname };\n        }\n      }\n    }\n\n    if (location) {\n      if (spanOp === 'pageload') {\n        // Re-run the pageload transaction update with the newly loaded routes\n        updatePageloadTransaction({\n          activeRootSpan,\n          location: { pathname: location.pathname },\n          routes: Array.from(allRoutes),\n          allRoutes: Array.from(allRoutes),\n        });\n      } else if (spanOp === 'navigation') {\n        // For navigation spans, update the name with the newly loaded routes\n        updateNavigationSpan(activeRootSpan, location, Array.from(allRoutes), false, _matchRoutes);\n      }\n    }\n  }\n}\n\n/**\n * Updates a navigation span with the correct route name after lazy routes have been loaded.\n */\nexport function updateNavigationSpan(\n  activeRootSpan: Span,\n  location: Location,\n  allRoutes: RouteObject[],\n  forceUpdate = false,\n  matchRoutes: MatchRoutes,\n): void {\n  // Check if this span has already been named to avoid multiple updates\n  // But allow updates if this is a forced update (e.g., when lazy routes are loaded)\n  const hasBeenNamed =\n    !forceUpdate && (activeRootSpan as { __sentry_navigation_name_set__?: boolean })?.__sentry_navigation_name_set__;\n\n  if (!hasBeenNamed) {\n    // Get fresh branches for the current location with all loaded routes\n    const currentBranches = matchRoutes(allRoutes, location);\n    const [name, source] = resolveRouteNameAndSource(\n      location,\n      allRoutes,\n      allRoutes,\n      (currentBranches as RouteMatch[]) || [],\n      '',\n    );\n\n    // Only update if we have a valid name and the span hasn't finished\n    const spanJson = spanToJSON(activeRootSpan);\n    if (name && !spanJson.timestamp) {\n      activeRootSpan.updateName(name);\n      activeRootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n\n      // Mark this span as having its name set to prevent future updates\n      addNonEnumerableProperty(\n        activeRootSpan as { __sentry_navigation_name_set__?: boolean },\n        '__sentry_navigation_name_set__',\n        true,\n      );\n    }\n  }\n}\n\n/**\n * Creates a wrapCreateBrowserRouter function that can be used with all React Router v6 compatible versions.\n */\nexport function createV6CompatibleWrapCreateBrowserRouter<\n  TState extends RouterState = RouterState,\n  TRouter extends Router<TState> = Router<TState>,\n>(\n  createRouterFunction: CreateRouterFunction<TState, TRouter>,\n  version: V6CompatibleVersion,\n): CreateRouterFunction<TState, TRouter> {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(\n        `reactRouterV${version}Instrumentation was unable to wrap the \\`createRouter\\` function because of one or more missing parameters.`,\n      );\n\n    return createRouterFunction;\n  }\n\n  return function (routes: RouteObject[], opts?: Record<string, unknown> & { basename?: string }): TRouter {\n    addRoutesToAllRoutes(routes);\n\n    // Check for async handlers that might contain sub-route declarations (only if enabled)\n    if (_enableAsyncRouteHandlers) {\n      for (const route of routes) {\n        checkRouteForAsyncHandler(route, processResolvedRoutes);\n      }\n    }\n\n    // Wrap patchRoutesOnNavigation to detect when lazy routes are loaded\n    const wrappedOpts = wrapPatchRoutesOnNavigation(opts);\n\n    const router = createRouterFunction(routes, wrappedOpts);\n    const basename = opts?.basename;\n\n    const activeRootSpan = getActiveRootSpan();\n\n    // Track whether we've completed the initial pageload to properly distinguish\n    // between POPs that occur during pageload vs. legitimate back/forward navigation.\n    let isInitialPageloadComplete = false;\n    let hasSeenPageloadSpan = !!activeRootSpan && spanToJSON(activeRootSpan).op === 'pageload';\n    let hasSeenPopAfterPageload = false;\n\n    // The initial load ends when `createBrowserRouter` is called.\n    // This is the earliest convenient time to update the transaction name.\n    // Callbacks to `router.subscribe` are not called for the initial load.\n    if (router.state.historyAction === 'POP' && activeRootSpan) {\n      updatePageloadTransaction({\n        activeRootSpan,\n        location: router.state.location,\n        routes,\n        basename,\n        allRoutes: Array.from(allRoutes),\n      });\n    }\n\n    router.subscribe((state: RouterState) => {\n      // Track pageload completion to distinguish POPs during pageload from legitimate back/forward navigation\n      if (!isInitialPageloadComplete) {\n        const currentRootSpan = getActiveRootSpan();\n        const isCurrentlyInPageload = currentRootSpan && spanToJSON(currentRootSpan).op === 'pageload';\n\n        if (isCurrentlyInPageload) {\n          hasSeenPageloadSpan = true;\n        } else if (hasSeenPageloadSpan) {\n          // Pageload span was active but is now gone - pageload has completed\n          if (state.historyAction === 'POP' && !hasSeenPopAfterPageload) {\n            // Pageload ended: ignore the first POP after pageload\n            hasSeenPopAfterPageload = true;\n          } else {\n            // Pageload ended: either non-POP action or subsequent POP\n            isInitialPageloadComplete = true;\n          }\n        }\n        // If we haven't seen a pageload span yet, keep waiting (don't mark as complete)\n      }\n\n      const shouldHandleNavigation =\n        state.historyAction === 'PUSH' || (state.historyAction === 'POP' && isInitialPageloadComplete);\n\n      if (shouldHandleNavigation) {\n        const navigationHandler = (): void => {\n          handleNavigation({\n            location: state.location,\n            routes,\n            navigationType: state.historyAction,\n            version,\n            basename,\n            allRoutes: Array.from(allRoutes),\n          });\n        };\n\n        // Wait for the next render if loading an unsettled route\n        if (state.navigation.state !== 'idle') {\n          requestAnimationFrame(navigationHandler);\n        } else {\n          navigationHandler();\n        }\n      }\n    });\n\n    return router;\n  };\n}\n\n/**\n * Creates a wrapCreateMemoryRouter function that can be used with all React Router v6 compatible versions.\n */\nexport function createV6CompatibleWrapCreateMemoryRouter<\n  TState extends RouterState = RouterState,\n  TRouter extends Router<TState> = Router<TState>,\n>(\n  createRouterFunction: CreateRouterFunction<TState, TRouter>,\n  version: V6CompatibleVersion,\n): CreateRouterFunction<TState, TRouter> {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(\n        `reactRouterV${version}Instrumentation was unable to wrap the \\`createMemoryRouter\\` function because of one or more missing parameters.`,\n      );\n\n    return createRouterFunction;\n  }\n\n  return function (\n    routes: RouteObject[],\n    opts?: Record<string, unknown> & {\n      basename?: string;\n      initialEntries?: (string | { pathname: string })[];\n      initialIndex?: number;\n    },\n  ): TRouter {\n    addRoutesToAllRoutes(routes);\n\n    // Check for async handlers that might contain sub-route declarations (only if enabled)\n    if (_enableAsyncRouteHandlers) {\n      for (const route of routes) {\n        checkRouteForAsyncHandler(route, processResolvedRoutes);\n      }\n    }\n\n    // Wrap patchRoutesOnNavigation to detect when lazy routes are loaded\n    const wrappedOpts = wrapPatchRoutesOnNavigation(opts, true);\n\n    const router = createRouterFunction(routes, wrappedOpts);\n    const basename = opts?.basename;\n\n    let initialEntry = undefined;\n\n    const initialEntries = opts?.initialEntries;\n    const initialIndex = opts?.initialIndex;\n\n    const hasOnlyOneInitialEntry = initialEntries && initialEntries.length === 1;\n    const hasIndexedEntry = initialIndex !== undefined && initialEntries && initialEntries[initialIndex];\n\n    initialEntry = hasOnlyOneInitialEntry\n      ? initialEntries[0]\n      : hasIndexedEntry\n        ? initialEntries[initialIndex]\n        : undefined;\n\n    const location = initialEntry\n      ? typeof initialEntry === 'string'\n        ? { pathname: initialEntry }\n        : initialEntry\n      : router.state.location;\n\n    const memoryActiveRootSpan = getActiveRootSpan();\n\n    if (router.state.historyAction === 'POP' && memoryActiveRootSpan) {\n      updatePageloadTransaction({\n        activeRootSpan: memoryActiveRootSpan,\n        location,\n        routes,\n        basename,\n        allRoutes: Array.from(allRoutes),\n      });\n    }\n\n    // Track whether we've completed the initial pageload to properly distinguish\n    // between POPs that occur during pageload vs. legitimate back/forward navigation.\n    let isInitialPageloadComplete = false;\n    let hasSeenPageloadSpan = !!memoryActiveRootSpan && spanToJSON(memoryActiveRootSpan).op === 'pageload';\n    let hasSeenPopAfterPageload = false;\n\n    router.subscribe((state: RouterState) => {\n      // Track pageload completion to distinguish POPs during pageload from legitimate back/forward navigation\n      if (!isInitialPageloadComplete) {\n        const currentRootSpan = getActiveRootSpan();\n        const isCurrentlyInPageload = currentRootSpan && spanToJSON(currentRootSpan).op === 'pageload';\n\n        if (isCurrentlyInPageload) {\n          hasSeenPageloadSpan = true;\n        } else if (hasSeenPageloadSpan) {\n          // Pageload span was active but is now gone - pageload has completed\n          if (state.historyAction === 'POP' && !hasSeenPopAfterPageload) {\n            // Pageload ended: ignore the first POP after pageload\n            hasSeenPopAfterPageload = true;\n          } else {\n            // Pageload ended: either non-POP action or subsequent POP\n            isInitialPageloadComplete = true;\n          }\n        }\n        // If we haven't seen a pageload span yet, keep waiting (don't mark as complete)\n      }\n\n      const location = state.location;\n\n      const shouldHandleNavigation =\n        state.historyAction === 'PUSH' || (state.historyAction === 'POP' && isInitialPageloadComplete);\n\n      if (shouldHandleNavigation) {\n        const navigationHandler = (): void => {\n          handleNavigation({\n            location,\n            routes,\n            navigationType: state.historyAction,\n            version,\n            basename,\n            allRoutes: Array.from(allRoutes),\n          });\n        };\n\n        // Wait for the next render if loading an unsettled route\n        if (state.navigation.state !== 'idle') {\n          requestAnimationFrame(navigationHandler);\n        } else {\n          navigationHandler();\n        }\n      }\n    });\n\n    return router;\n  };\n}\n\n/**\n * Creates a browser tracing integration that can be used with all React Router v6 compatible versions.\n */\nexport function createReactRouterV6CompatibleTracingIntegration(\n  options: Parameters<typeof browserTracingIntegration>[0] & ReactRouterOptions,\n  version: V6CompatibleVersion,\n): Integration {\n  const integration = browserTracingIntegration({ ...options, instrumentPageLoad: false, instrumentNavigation: false });\n\n  const {\n    useEffect,\n    useLocation,\n    useNavigationType,\n    createRoutesFromChildren,\n    matchRoutes,\n    stripBasename,\n    enableAsyncRouteHandlers = false,\n    instrumentPageLoad = true,\n    instrumentNavigation = true,\n  } = options;\n\n  return {\n    ...integration,\n    setup(client) {\n      integration.setup(client);\n\n      _useEffect = useEffect;\n      _useLocation = useLocation;\n      _useNavigationType = useNavigationType;\n      _matchRoutes = matchRoutes;\n      _createRoutesFromChildren = createRoutesFromChildren;\n      _enableAsyncRouteHandlers = enableAsyncRouteHandlers;\n\n      // Initialize the router utils with the required dependencies\n      initializeRouterUtils(matchRoutes, stripBasename || false);\n    },\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n\n      const initPathName = WINDOW.location?.pathname;\n      if (instrumentPageLoad && initPathName) {\n        startBrowserTracingPageLoadSpan(client, {\n          name: initPathName,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.pageload.react.reactrouter_v${version}`,\n          },\n        });\n      }\n\n      if (instrumentNavigation) {\n        CLIENTS_WITH_INSTRUMENT_NAVIGATION.add(client);\n      }\n    },\n  };\n}\n\nexport function createV6CompatibleWrapUseRoutes(origUseRoutes: UseRoutes, version: V6CompatibleVersion): UseRoutes {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(\n        'reactRouterV6Instrumentation was unable to wrap `useRoutes` because of one or more missing parameters.',\n      );\n\n    return origUseRoutes;\n  }\n\n  const SentryRoutes: React.FC<{\n    children?: React.ReactNode;\n    routes: RouteObject[];\n    locationArg?: Partial<Location> | string;\n  }> = (props: { children?: React.ReactNode; routes: RouteObject[]; locationArg?: Partial<Location> | string }) => {\n    const isMountRenderPass = React.useRef(true);\n    const { routes, locationArg } = props;\n\n    const Routes = origUseRoutes(routes, locationArg);\n\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n\n    // A value with stable identity to either pick `locationArg` if available or `location` if not\n    const stableLocationParam =\n      typeof locationArg === 'string' || locationArg?.pathname ? (locationArg as { pathname: string }) : location;\n\n    _useEffect(() => {\n      const normalizedLocation =\n        typeof stableLocationParam === 'string' ? { pathname: stableLocationParam } : stableLocationParam;\n\n      if (isMountRenderPass.current) {\n        addRoutesToAllRoutes(routes);\n\n        updatePageloadTransaction({\n          activeRootSpan: getActiveRootSpan(),\n          location: normalizedLocation,\n          routes,\n          allRoutes: Array.from(allRoutes),\n        });\n        isMountRenderPass.current = false;\n      } else {\n        handleNavigation({\n          location: normalizedLocation,\n          routes,\n          navigationType,\n          version,\n          allRoutes: Array.from(allRoutes),\n        });\n      }\n    }, [navigationType, stableLocationParam]);\n\n    return Routes;\n  };\n\n  // eslint-disable-next-line react/display-name\n  return (routes: RouteObject[], locationArg?: Partial<Location> | string): React.ReactElement | null => {\n    return <SentryRoutes routes={routes} locationArg={locationArg} />;\n  };\n}\n\nfunction wrapPatchRoutesOnNavigation(\n  opts: Record<string, unknown> | undefined,\n  isMemoryRouter = false,\n): Record<string, unknown> {\n  if (!opts || !('patchRoutesOnNavigation' in opts) || typeof opts.patchRoutesOnNavigation !== 'function') {\n    return opts || {};\n  }\n\n  const originalPatchRoutes = opts.patchRoutesOnNavigation;\n  return {\n    ...opts,\n    patchRoutesOnNavigation: async (args: unknown) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n      const targetPath = (args as any)?.path;\n\n      // For browser router, wrap the patch function to update span during patching\n      if (!isMemoryRouter) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        const originalPatch = (args as any)?.patch;\n        if (originalPatch) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n          (args as any).patch = (routeId: string, children: RouteObject[]) => {\n            addRoutesToAllRoutes(children);\n            const activeRootSpan = getActiveRootSpan();\n            if (activeRootSpan && (spanToJSON(activeRootSpan) as { op?: string }).op === 'navigation') {\n              updateNavigationSpan(\n                activeRootSpan,\n                { pathname: targetPath, search: '', hash: '', state: null, key: 'default' },\n                Array.from(allRoutes),\n                true, // forceUpdate = true since we're loading lazy routes\n                _matchRoutes,\n              );\n            }\n            return originalPatch(routeId, children);\n          };\n        }\n      }\n\n      const result = await originalPatchRoutes(args);\n\n      // Update navigation span after routes are patched\n      const activeRootSpan = getActiveRootSpan();\n      if (activeRootSpan && (spanToJSON(activeRootSpan) as { op?: string }).op === 'navigation') {\n        // Determine pathname based on router type\n        let pathname: string | undefined;\n        if (isMemoryRouter) {\n          // For memory routers, only use targetPath\n          pathname = targetPath;\n        } else {\n          // For browser routers, use targetPath or fall back to window.location\n          pathname = targetPath || WINDOW.location?.pathname;\n        }\n\n        if (pathname) {\n          updateNavigationSpan(\n            activeRootSpan,\n            { pathname, search: '', hash: '', state: null, key: 'default' },\n            Array.from(allRoutes),\n            false, // forceUpdate = false since this is after lazy routes are loaded\n            _matchRoutes,\n          );\n        }\n      }\n\n      return result;\n    },\n  };\n}\n\nexport function handleNavigation(opts: {\n  location: Location;\n  routes: RouteObject[];\n  navigationType: Action;\n  version: V6CompatibleVersion;\n  matches?: AgnosticDataRouteMatch;\n  basename?: string;\n  allRoutes?: RouteObject[];\n}): void {\n  const { location, routes, navigationType, version, matches, basename, allRoutes } = opts;\n  const branches = Array.isArray(matches) ? matches : _matchRoutes(routes, location, basename);\n\n  const client = getClient();\n  if (!client || !CLIENTS_WITH_INSTRUMENT_NAVIGATION.has(client)) {\n    return;\n  }\n\n  // Avoid starting a navigation span on initial load when a pageload root span is active.\n  // This commonly happens when lazy routes resolve during the first render and React Router emits a POP.\n  const activeRootSpan = getActiveRootSpan();\n  if (activeRootSpan && spanToJSON(activeRootSpan).op === 'pageload' && navigationType === 'POP') {\n    return;\n  }\n\n  if ((navigationType === 'PUSH' || navigationType === 'POP') && branches) {\n    const [name, source] = resolveRouteNameAndSource(\n      location,\n      routes,\n      allRoutes || routes,\n      branches as RouteMatch[],\n      basename,\n    );\n\n    const activeSpan = getActiveSpan();\n    const spanJson = activeSpan && spanToJSON(activeSpan);\n    const isAlreadyInNavigationSpan = spanJson?.op === 'navigation';\n\n    // Cross usage can result in multiple navigation spans being created without this check\n    if (!isAlreadyInNavigationSpan) {\n      const navigationSpan = startBrowserTracingNavigationSpan(client, {\n        name,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: `auto.navigation.react.reactrouter_v${version}`,\n        },\n      });\n\n      // Patch navigation span to handle early cancellation (e.g., document.hidden)\n      if (navigationSpan) {\n        patchNavigationSpanEnd(navigationSpan, location, routes, basename, allRoutes);\n      }\n    }\n  }\n}\n\n/* Only exported for testing purposes */\nexport function addRoutesToAllRoutes(routes: RouteObject[]): void {\n  routes.forEach(route => {\n    const extractedChildRoutes = getChildRoutesRecursively(route);\n\n    extractedChildRoutes.forEach(r => {\n      allRoutes.add(r);\n    });\n  });\n}\n\nfunction getChildRoutesRecursively(route: RouteObject, allRoutes: Set<RouteObject> = new Set()): Set<RouteObject> {\n  if (!allRoutes.has(route)) {\n    allRoutes.add(route);\n\n    if (route.children && !route.index) {\n      route.children.forEach(child => {\n        const childRoutes = getChildRoutesRecursively(child, allRoutes);\n\n        childRoutes.forEach(r => {\n          allRoutes.add(r);\n        });\n      });\n    }\n  }\n\n  return allRoutes;\n}\n\nfunction updatePageloadTransaction({\n  activeRootSpan,\n  location,\n  routes,\n  matches,\n  basename,\n  allRoutes,\n}: {\n  activeRootSpan: Span | undefined;\n  location: Location;\n  routes: RouteObject[];\n  matches?: AgnosticDataRouteMatch;\n  basename?: string;\n  allRoutes?: RouteObject[];\n}): void {\n  const branches = Array.isArray(matches)\n    ? matches\n    : (_matchRoutes(allRoutes || routes, location, basename) as unknown as RouteMatch[]);\n\n  if (branches) {\n    const [name, source] = resolveRouteNameAndSource(location, routes, allRoutes || routes, branches, basename);\n\n    getCurrentScope().setTransactionName(name || '/');\n\n    if (activeRootSpan) {\n      activeRootSpan.updateName(name);\n      activeRootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n\n      // Patch span.end() to ensure we update the name one last time before the span is sent\n      patchPageloadSpanEnd(activeRootSpan, location, routes, basename, allRoutes);\n    }\n  }\n}\n\n/**\n * Patches the span.end() method to update the transaction name one last time before the span is sent.\n * This handles cases where the span is cancelled early (e.g., document.hidden) before lazy routes have finished loading.\n */\nfunction patchSpanEnd(\n  span: Span,\n  location: Location,\n  routes: RouteObject[],\n  basename: string | undefined,\n  _allRoutes: RouteObject[] | undefined,\n  spanType: 'pageload' | 'navigation',\n): void {\n  const patchedPropertyName = `__sentry_${spanType}_end_patched__` as const;\n  const hasEndBeenPatched = (span as unknown as Record<string, boolean | undefined>)?.[patchedPropertyName];\n\n  if (hasEndBeenPatched || !span.end) {\n    return;\n  }\n\n  const originalEnd = span.end.bind(span);\n\n  span.end = function patchedEnd(...args) {\n    try {\n      // Only update if the span source is not already 'route' (i.e., it hasn't been parameterized yet)\n      const spanJson = spanToJSON(span);\n      const currentSource = spanJson.data?.[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n      if (currentSource !== 'route') {\n        // Last chance to update the transaction name with the latest route info\n        // Use the live global allRoutes Set to include any lazy routes loaded after patching\n        const currentAllRoutes = Array.from(allRoutes);\n        const branches = _matchRoutes(\n          currentAllRoutes.length > 0 ? currentAllRoutes : routes,\n          location,\n          basename,\n        ) as unknown as RouteMatch[];\n\n        if (branches) {\n          const [name, source] = resolveRouteNameAndSource(\n            location,\n            routes,\n            currentAllRoutes.length > 0 ? currentAllRoutes : routes,\n            branches,\n            basename,\n          );\n\n          // Only update if we have a valid name\n          if (name && (spanType === 'pageload' || !spanJson.timestamp)) {\n            span.updateName(name);\n            span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);\n          }\n        }\n      }\n    } catch (error) {\n      // Silently catch errors to ensure span.end() is always called\n      DEBUG_BUILD && debug.warn(`Error updating span details before ending: ${error}`);\n    }\n\n    return originalEnd(...args);\n  };\n\n  // Mark this span as having its end() method patched to prevent duplicate patching\n  addNonEnumerableProperty(span as unknown as Record<string, boolean>, patchedPropertyName, true);\n}\n\nfunction patchPageloadSpanEnd(\n  span: Span,\n  location: Location,\n  routes: RouteObject[],\n  basename: string | undefined,\n  _allRoutes: RouteObject[] | undefined,\n): void {\n  patchSpanEnd(span, location, routes, basename, _allRoutes, 'pageload');\n}\n\nfunction patchNavigationSpanEnd(\n  span: Span,\n  location: Location,\n  routes: RouteObject[],\n  basename: string | undefined,\n  _allRoutes: RouteObject[] | undefined,\n): void {\n  patchSpanEnd(span, location, routes, basename, _allRoutes, 'navigation');\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function createV6CompatibleWithSentryReactRouterRouting<P extends Record<string, any>, R extends React.FC<P>>(\n  Routes: R,\n  version: V6CompatibleVersion,\n): R {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_createRoutesFromChildren || !_matchRoutes) {\n    DEBUG_BUILD &&\n      debug.warn(`reactRouterV6Instrumentation was unable to wrap Routes because of one or more missing parameters.\n      useEffect: ${_useEffect}. useLocation: ${_useLocation}. useNavigationType: ${_useNavigationType}.\n      createRoutesFromChildren: ${_createRoutesFromChildren}. matchRoutes: ${_matchRoutes}.`);\n\n    return Routes;\n  }\n\n  const SentryRoutes: React.FC<P> = (props: P) => {\n    const isMountRenderPass = React.useRef(true);\n\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n\n    _useEffect(\n      () => {\n        const routes = _createRoutesFromChildren(props.children) as RouteObject[];\n\n        if (isMountRenderPass.current) {\n          addRoutesToAllRoutes(routes);\n\n          updatePageloadTransaction({\n            activeRootSpan: getActiveRootSpan(),\n            location,\n            routes,\n            allRoutes: Array.from(allRoutes),\n          });\n          isMountRenderPass.current = false;\n        } else {\n          handleNavigation({ location, routes, navigationType, version, allRoutes: Array.from(allRoutes) });\n        }\n      },\n      // `props.children` is purposely not included in the dependency array, because we do not want to re-run this effect\n      // when the children change. We only want to start transactions when the location or navigation type change.\n      [location, navigationType],\n    );\n\n    // @ts-expect-error Setting more specific React Component typing for `R` generic above\n    // will break advanced type inference done by react router params\n    return <Routes {...props} />;\n  };\n\n  hoistNonReactStatics(SentryRoutes, Routes);\n\n  // @ts-expect-error Setting more specific React Component typing for `R` generic above\n  // will break advanced type inference done by react router params\n  return SentryRoutes;\n}\n\nfunction getActiveRootSpan(): Span | undefined {\n  const span = getActiveSpan();\n  const rootSpan = span ? getRootSpan(span) : undefined;\n\n  if (!rootSpan) {\n    return undefined;\n  }\n\n  const op = spanToJSON(rootSpan).op;\n\n  // Only use this root span if it is a pageload or navigation span\n  return op === 'navigation' || op === 'pageload' ? rootSpan : undefined;\n}\n"],"names":[],"mappings":"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"}